
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tutorial system</title>
</head>
<body>

    <style>
        body { 
    font-family: 'Arial', sans-serif;
    margin: 0;
    padding:0;
        }      

 nav{
        background-color: rgb(0, 200, 255);
        color:antiquewhite;
        padding:10px 0;
        margin-bottom: 20px;
 }
        
        
        nav ul {
            list-style-type:none;
            padding: 0%;
            display:flex;
           justify-content: center;
        }
        nav ul li a{
          text-decoration: none;
          font-weight: bold;
          color:white;
          padding:10px 16px;
        
        }

.container {
   max-width: 85%;
   margin:0 auto;
   padding:0
}
h1 {
    text-align: center;
    color: rgb(0, 4, 255);
    margin: 40px 0;
    }
h2{
    color:rgb(0, 255, 13);
}

.content {
    width:50%;
    height:100px;
    line-height: 1.6em;
    margin-bottom: 20px;
   
}
.left-paragraph{
  float:left;
width:40%;
}



.right-paragraph{
  float:right;
width:50%;
}

.responsive{
    width:100%;
  max-width: 400px;
height:auto;
  
  

}
.footer {
  background-color:rgb(0, 200, 255);
  text-align: center;
    padding: 10px 0;
  position:absolute;
  font-weight: bold;
  width:100%;
  left:0;
  right:0;
}

.footer-content {
  display:flex;
  justify-content:center;
  flex-wrap: wrap;
}
.footer-section {
  margin: 10px;
}
 
    </style>
     <nav>
        <ul>
          <li><a href="home.html">HOME</a></li>
            <li><a href="tutorial.html">SPM</a></li>
            <li><a href="mcq.html"> MCQ</a></li>
    </nav>
    
    <div class="container">
        <section id="introduction">
            <img src="s1.jpg"  height="auto"width="105%">
        <h1>INTRODUCTION TO SOFTWARE PROJECT MANEGMENT</h1>
        <p>
            <b>software project manaaegment is all about planning, orgnizing, anad controlling software devlopment project.
            it involves tasks like setting goals, maninaning resources,and coordinating team members. it's like being the caption of a ship,making sure everything runs smoothly, it's a fascinating fields!</b>
         </section> </p>
        <h1>What is SPM?(software project managment)</h1>
        <p>Software Project Management (SPM) is a proper way of planning and leading software projects.
             It is a part of project management in which software projects are planned, implemented,
              monitored, and controlled. This article focuses on discussing Software Project Management (SPM).</p>
        <h2>Need of software project manaaegment</h2>
        <p>software is a non-physical product. Software development is a new stream in business and there is very little experience in building software products. Most of the software products are made to fit clients’ requirements. The most important is that basic technology changes and advances so frequently and rapidly that the experience of one product may not be applied to the other one. Such types of business and environmental constraints increase risk in software development hence it is essential to manage software projects efficiently. It is necessary for an organization to deliver quality products, keep the cost within the client’s budget constraint, and deliver 
            the project as per schedule</p>
            <h2>type of management in SPM</h2>
            1.<b>Conflict manaaegment:-</b>
            Conflict management is the process to restrict the negative features of conflict while increasing the positive features of conflict. The goal of conflict management is to improve learning and group results including efficacy or performance in an organizational setting. Properly managed conflict can enhance group results.
            <br></br>
2. <b>Risk Management:-</b>
Risk management is the analysis and identification of risks that is followed by synchronized and economical implementation of resources to minimize, operate and control the possibility or effect of unfortunate events or to maximize the realization of opportunities.
<br></br>
3.<b> requirement Management:-</b>
It is the process of analyzing, prioritizing, tracking, and documenting requirements and then supervising change and communicating to pertinent stakeholders. It is a continuous process during a project.
<br></br>
4.<b> Change Management:-</b>
Change management is a systematic approach to dealing with the transition or transformation of an organization’s goals, processes, or technologies. The purpose of change management is to execute strategies for effecting change, controlling change, and helping people to adapt to change.
<br></br>
5. <b> Configuration Management:-</b>
Software configuration management is the process of controlling and tracking changes in the software, part of the larger cross-disciplinary field of configuration management
      <h2 >SOFTWARE DEVLOPMENT LIFE CYCLE MODLE</h2>
      <p>Software Development life cycle (SDLC) is a spiritual model used in project management that defines the stages include in an information system development project, from an initial feasibility study to the maintenance of the completed application.
          There are different software development life cycle models specify and design, which are followed during the software development phase. These models are also called "Software Development Process Models." Each process model follows a series of phase unique to its type to ensure success in the step of software development.</p>
 <img src="sdlc.jpg" class="responsive"alt="image" style="float: right;width: 50%;margin-top: -40px; "weight="50%" height="100%;"><br></br>
          <b>Here are some important phase of SDLC life cycle:-</b><br></br>
          1.WATERFALL MODEL<br></br>
          2.SPIRAL MODEL<br></br>
          3.PROTOTYPE MODE<br></br>
          4.V-MODEL<br></br>
          <P class="left-paragraph">1.<b>WATERFALL MODEL</b> waterfall model is a continuous software development model in which development is seen as flowing steadily downwards (like a waterfall) through the steps of requirements analysis, design, implementation, testing (validation), integration, and maintenance.
            Linear ordering of activities has some significant consequences. First, to identify the end of a phase and the beginning of the next, some certification techniques have to be employed at the end of each step. Some verification and validation usually do this mean that will ensure that the output of the stage is consistent with its input (which is the output of the previous step), and that the output of the stage is consistent with the overall requirements of the system.<br></br><b >The waterfall model is divided into various stages, which are as follows:</b><br></br>
            <b>a.Requirement collection</b><br></br>
<b>b.Feasibility study</b><br></br>
<b>c.Coding</b><br></br>
<b>d.Testing</b><br></br>
<b>e.Installation</b><br></br>
<b>f.Maintenance</b><br></br>
   <img src="water.jpg" alt="water" class="responsive"><br></br>
         <p class="right-paragraph"><b>2.SPIRAL MODEL:-</b>The Spiral Model is a Software Development Life Cycle (SDLC) model that provides a systematic and iterative approach to software development. It is particularly useful for managing risk in complex and large-scale projects. Let’s dive into the details:<br></br>Phases of the Spiral Model:<br></br>    
          <b> Planning:</b> In this initial phase, the project scope is determined, and a plan is created for the next iteration of the spiral.<br></br>
          <b>Risk Analysis: </b> risks associated with the project are identified and evaluated.<br></br>
          <b>Engineering:</b> Software development takes place based on the requirements gathered in the previous iteration.<br></br>
          <b>Evaluation:</b> The software is evaluated to determine if it meets customer requirements and maintains high quality.The next iteration begins with a new planning phase, based on the results of the evaluation<br></br></p>
           <img src="sp.jpg" alt="sp"class="responsive"><br></br>
           <p><b>3.PROTOTYPE MODEL:</b>The Prototyping Model is a dynamic approach used during the software development life cycle (SDLC). It involves creating a simplified working replica of the future product or system to test its concept and functionality. Here are the key points about this model:<br></br>
            1.Concept and Purpose:The Prototyping Model is employed when project requirements are vague or subject to change.
It allows developers to create an initial version of the software product, known as a prototype, which showcases the basic features and functionality desired by customers.
.Steps in the Prototyping Model<br></br>
1.Requirement Gathering and Analysis: In this initial step, users’ expectations and system requirements are collected.<br></br>
2.Quick Design: A basic design overview is created to outline the requirements.<br></br>
3.Build a Prototype: An actual prototype is constructed based on the knowledge gained from the design.<br></br>
4.Refining Prototype: The prototype is iteratively improved based on user feedback until an acceptable version is achieved.<br></br>5.Initial User Evaluation: Preliminary testing occurs, and feedback from users helps refine the prototype.<br></br>6.Refining Prototype: The prototype is iteratively improved based on user feedback until an acceptable version is achieved.<br></br>7.Implement Product and Maintain: The final system is tested, distributed, and maintained.<br></br></p>
<img src="pr.jpg" alt="pr" class="responsive"><br></br>
<img src="pt.webp" alt="pt" class="responsive"style="float: right;margin-top: -200px" ><br></br>
<p>4.<b>V- MODEL:-</b>The V-model is a type of SDLC model where the process executes sequentially in a V-shape. It is also known as the Verification and Validation model. It is based on the association of a testing phase for each corresponding development stage. The development of each step is directly associated with the testing phase. The next phase starts only after completion of the previous phase i.e., for each development activity, there is a testing activity corresponding to it. </p>
<img src="v.png" alt="v" class="responsive"><br>
<img src="ad.webp" alt="image"class="responsive"style="float: right;margin-top: -200px"><br></br>
<h2> CMM capability muturity model</h2>
<p>The Capability Maturity Model (CMM) is a framework used to analyze and improve the software development process within an organization. Developed by the Software Engineering Institute (SEI) at Carnegie Mellon University in 1987, CMM provides guidelines for assessing an organization’s approach and techniques for developing software products. Here are some key points about CMM.<br></br>
<b>CMM is structured into five levels of maturity:</b><br></br>1.Initial - Processes are unpredictable and reactive.<br></br>2.Repeatable - Basic project management processes are established.<br></br>3.Defined - Processes are documented and standardized.<br></br>4.Managed - Processes are measured and controlled.<br></br>5.Optimizing - Focus on continuous process improvement<br></br></p>
<img src="cmm.png" alt="cmm" class="responsive" style="float:right;margin-top: -200px"><br>
<h2>COCOMO MODEL</h2>
<P>The COCOMO (Constructive Cost Model) is a procedural cost estimate model for software projects. It was proposed by Barry Boehm in 1981 and is based on the study of 63 projects. The model is used to predict various parameters associated with a software project, such as size, effort, cost, time, and quality.<br></br>
   <b> Types of COCOMO Model</b> <br></br>1.Organic<br></br>2. Semidetached<br></br>Embedded<br></br>
 <b>1.Organic:</b> A development project can be treated of the organic type, if the project deals with developing a well-understood application program, the size of the development team is reasonably small, and the team members are experienced in developing similar methods of projects. Examples of this type of projects are simple business systems, simple inventory management systems, and data processing systems.<br></br>
 <b>2. Semidetached:</b> A development project can be treated with semidetached type if the development consists of a mixture of experienced and inexperienced staff. Team members may have finite experience in related systems but may be unfamiliar with some aspects of the order being developed. Example of Semidetached system includes developing a new operating system (OS), a Database Management System (DBMS), and complex inventory management system.<br></br>
 <b>3.Embedded:</b> A development project is treated to be of an embedded type, if the software being developed is strongly coupled to complex hardware, or if the stringent regulations on the operational method exist. For Example: ATM, Air Traffic control.
 For three product categories, Bohem provides a different set of expression to predict effort (in a unit of person month)and development time from the size of estimation in KLOC(Kilo Line of code) efforts estimation takes into account the productivity loss due to holidays, weekly off, coffee breaks, etc.<br></b>
 <b>ADWANTAGES</b><br></br>
1.It works on historical data and provides more accurate details.<br></br>2.Easy to implement with various factors. One can easily understand how it works.<br></br>3.Easy to estimate the total cost of the project.<br></br>4.The drivers are very helpful to understand the impact of the different factors that affect project crises.<br></br>
<b>DISADWANTAGES</b><br></br>1.It ignores the hardware issues as well as the personal turnover level.<br></br>2.It ignores all the documentation and requirements.<br></br>3.It mostly depends on time factors.<br></br>4.It limits the accuracy of software costs.<br></br>5.It oversimplifies the impact of safety or security aspects.<br></br>6.It also ignores customer skills, cooperation, and knowledge.<br></br>
<img src="CM.gif" alt="cm"class="responsive" style="float: right;margin-top: -400px; "><br>
<h2>PROJECT MANEGMENT AND PROJECT MANEGMENT TOOLS</h2><br><h2>what is project management?</H2><br>
<b> project management is the application of knowledge, skills, tools, and techniques to project activities to meet the project requirements. It involves planning, initiating, executing, monitoring, controlling, and closing work to achieve specific goals and meet specific success criteria at the specified time. The primary challenge of project management is to achieve all of the project goals within the given constraints.</b><br></br>
<img src="rules.png" class="responsive" height="auto" width="100%">
    <b>1. Define goals: Define your goals before starting the project.</b><br></br><b>2. Set milestones: Set milestones and track progress.</b><br></br> <b>3. Communicate: Communicate frequently with your team.</b><br></br><b>4. Allow time: Allow time for discussions and decision-making.</b><br></br><b>5. don't micromanage: Don't micromanage during project execution.</b><br></br>    <b>6. Plan: Have a clear plan in place before starting any project.</b><br></br>
    <b>7. Monitor and control: Controlling and monitoring are essential parts of project management.</b><br></br>
    <b>8. Manage risk: Understand how each project impacts the overall portfolio.</b><br></br>
    <b>9. Wrap up: Wrap up the project and deliver on time</b><br></br>
<b><h2>SPM TOOLS</h2></b><br>
    <b> 1. CASE TOOL</b> <br>
    <b> 2. PLANNING AND SCHEDULING TOOL</b><br>
    <b>3. SPM-PROJECT MANEGMENT TOOL(MS-PROJECT 2000AND 2002)</b><br></br>
    1.<b>CASE tool:-A CASE (Computer power-assisted software package Engineering)</b> tool could be a generic term accustomed to denote any type of machine-driven support for software package engineering. In a very additional restrictive sense, a CASE tool suggests that any tool accustomed to automatize some activity related to software package development.
    Several CASE tools square measure obtainable. A number of these CASE tools assist in part-connected tasks like specification, structured analysis, design, coding, testing, etc, and other non-phase activities like project management and configuration management.<br>
    <b><h2>advantages of case tool</h2></b>1 .Case tool improved speed and reduce the time needed to complete a particular software development task.<br>2 . Development of DFD , Gantt chart, PERT chart can be very tedious if done manually. CASE tools take away most of such drudges..<br>
    3 . When procedures are coded by a CASE tools they give a consistent look.<br>
    4 . In addition to the enforcement of consistence tools, CASE tools can also ensure completeness.<br>
    5 . Use of CASE tools increases the likelihood of meeting user requirements.<br>
    6 . One major advantage of CASE tools is that it facilitates prototype.<br>
    <b><h2>disadvantages of case tool</h2></b><br>1 . There is no standardization yet among the different CASE tools available in the market.<br>2 . CASE tools generally used diagram to represent the modeling and reporting of analysis anddevelopment work.<br>3 . Case tool have a limited scope.<br>
4 . A bad analysts or designer  can never become a good analysts or designer by just using a sophisticated case tool.<br></br>
<b>2.planning and scheduling tool:</b> Planning and scheduling tools in project management are software applications designed to assist project managers and teams in organizing, managing, and tracking their projects effectively. These tools provide a centralized platform to plan out the project’s tasks, assign them to team members, set deadlines, and monitor the progress of each task and the project as a whole.<br>                 
    <h2>Advantages of planning and scheduling tool</h2><br>
<b>1. Efficiency:- </b> tools speed up tasks like scheduling or resource allocation, saving time for creative problem-solving.<br>
<b>2. Clarity:-</b> They help in setting clear objectives and defining project goals.<br>
<b>3. Improved:-Communication:</b> communication and collaboration among team members.<br>
<b>4. Risk Management:-</b> more accurate risk analysis and mitigation strategies.<br>
<b>5. Quality Control:-</b> the quality of the final product by maintaining standards throughout the project lifecycle.<br>
<h2>Disadvantages of planning and scheduling tool</h2><br>
<b>1. Complexity:</b> tools can sometimes overcomplicate simple projects by recommending more steps than necessary, which can be counterproductive.<br>
<b>2. Learning Curve:</b> users may find these tools overwhelming due to their myriad features, requiring significant time for training and adaptation.<br>
<b>3. Over-Reliance on Technology:</b> Teams may become too dependent on these tools, and any technical issues can lead to work disruptions and missed deadlines<br>.
<b>4. Costs:</b> financial investment in these tools can be considerable, including purchase or subscription fees, training, maintenance, and updates.<br>
<b>5. Communication Barriers:</b> Sole reliance on digital tools for team interactions can lead to miscommunications, as non-verbal cues are absent.<br></br>
<b>3.SPM-PROJECT MANEGMENT TOOL(MS-PROJECT 2000AND 2002)</b>:<br><br> Microsoft Project 2000 and 2002 are project management tools that offer a variety of features to help users plan, track, and manage projects:<br>
<b>MS-Project 2000</b><br>
Provides users with increased flexibility for viewing, analyzing, and compiling data, and includes grouping tools to manipulate data
<b>MS-Project 2002</b><br>
Includes the Project Guide interactive help tool, which helps business managers plan, track, and manage schedules and resources.</p>
<h2>what is testing?</h2>
<p>Software testing can be stated as the process of verifying and validating whether a software or application is bug-free, meets the technical requirements as guided by its design and development, and meets the user requirements effectively and efficiently by handling all the exceptional and boundary cases.
software testingis a method to assess the functionality of the software program. The process checks whether the actual software matches the expected requirements and ensures the software is bug-free. The purpose of software testing is to identify the errors, faults, or missing requirements in contrast to actual requirements. It mainly aims at measuring the specification, functionality, and performance of a software program or application. <br>
<p class="left-paragraph"><b>Importance of Software Testing:</b>
<b>Defects can be identified early:</b> Software testing is important because if there are any bugs they can be identified early and can be fixed before the delivery of the software.<br><b>Improves quality of software: </b> Testing uncovers the defects in the software, and fixing them improves the quality of the software.<br><b>Increased customer satisfaction: </b> testing ensures reliability, security, and high performance which results in saving time, costs, and customer satisfaction. <br><b>Helps with scalability:</b> Software testing type non-functional testing helps to identify the scalability issues and the point where an application might stop working.<br><b>Saves time and money:</b> After the application is launched it will be very difficult to trace and resolve the issues, as performing this activity will incur more costs and time. Thus, it is better to conduct software testing at regular intervals during software development.</p>
<br><p class="right-paragraph"><b>Need for Software Testing</b><br>
Software bugs can cause potential monetary and human loss. There are many examples in history that clearly depicts that without the testing phase in software development lot of damage was incurred. Below are some examples:<br>1985: Canada’s Therac-25 radiation therapy malfunctioned due to a software bug and resulted in lethal radiation doses to patients leaving 3 injured and 3 people dead.<br>1994: China Airlines Airbus A300 crashed due to a software bug killing 264 people.<br>1996: A software bug caused U.S. bank accounts of 823 customers to be credited with 920 million US dollars.<br>1999: A software bug caused the failure of a $1.2 billion military satellite launch.<br>2015: A software bug in fighter plan F-35 resulted in making it unable to detect targets correctly.<br>2015: Bloomberg terminal in London crashed due to a software bug affecting 300,000 traders on the financial market and forcing the government to postpone the 3bn pound debt sale.
Starbucks was forced to close more than 60% of its outlet in the U.S. and Canada due to a software failure in its POS system.<br>
Nissan cars were forced to recall 1 million cars from the market due to a software failure in the car’s airbag sensory detectors.</p><br>
<img src="lv.png" alt="im"class="responsive"><br></br>
<img src="tp.png" alt="tp"class="responsive" style="float: right;margin-top: -300px;">

<h2>Manual testing</h2><br>
<p>Manual testing is a technique to test the software that is carried out using the functions and features of an application. In manual software testing, a tester carries out tests on the software by following a set of predefined test cases. In this testing, testers make test cases for the codes, test the software, and give the final report about that software. Manual testing is time-consuming because it is done by humans, and there is a chance of human errors.<br>
<h2>Advantages of manual testing</h2><br>
<b>1.Fast and accurate visual feedback: </b> detects almost every bug in the software application and is used to test the dynamically changing GUI designs like layout, text, etc.<br>
<b>2.Less expensive:</b> is less expensive as it does not require any high-level skill or a specific type of tool. <br>
<b>3.No coding is required:</b> No programming knowledge is required while using the black box testing method. It is easy to learn for the new testers. <br>
<b>4.Efficient for unplanned changes:</b> Manual testing is suitable in case of unplanned changes to the application, as it can be adopted easily.
<h2>Types of Manual Testing</h2><br>
<b>White Box Testing</b><br><b>Black Box Testing</b><br></br><b>1. white box testing:-</b> box testing techniques analyze the internal structures the used data structures, internal design, code structure, and the working of the software rather than just the functionality as in black box testing. It is also called glass box testing clear box testing or structural testing. White Box Testing is also known as transparent testing or open box testing. </b><br></br><b>2. Black box testing:</b>-Black-box testing is a type of software testing in which the tester is not concerned with the internal knowledge or implementation details of the software but rather focuses on validating the functionality based on the provided specifications or requirements.</b>
<h2>type of black box testing</h2><br>
<b>1.Functional Testing</b><br><b>2.Non-Functional Testing</b><br></br><b>1. Functional Testing</b>
    Functional Testing is a type of Software Testing in which the system is tested against the functional requirements and specifications. Functional testing ensures that the requirements or specifications are properly satisfied by the application. This type of testing is particularly concerned with the result of processing. It focuses on the simulation of actual system usage but does not develop any system structure assumptions. The article focuses on discussing function testing.</b><br></br><b>2.Non-Functional testing:-</b>Non-functional Testing is a type of Software Testing that is performed to verify the non-functional requirements of the application. It verifies whether the behavior of the system is as per the requirement or not. It tests all the aspects that are not tested in functional testing. Non-functional testing is a software testing technique that checks the non-functional attributes of the system. Non-functional testing is defined as a type of software testing to check non-functional aspects of a software application. It is designed to test the readiness of a system as per nonfunctional parameters which are never addressed by functional testing. Non-functional testing is as important as functional testing. <br>
</b><h2>Automation Testing</h2><br>
Automated Testing is a technique where the Tester writes scripts on their own and uses suitable Software or Automation Tool to test the software. It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manual Tester.<br>
<h2>Advantages of Automation Testing:</h2><br>
1.Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the results at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the application. <br>
2.Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus ensuring the best quality end product. <br>
3.Increases amount of test coverage: Using automation testing, more test cases can be created and executed for the application under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing of more complex applications and more features can be tested. 
</p><h2>Varification and validation </h2>
<b>Varification</b>
<p>Verification testing includes different activities such as business requirements, system requirements, design review, and code walkthrough while developing a product.
 It is also known as static testing, where we are ensuring that "we are developing the right product or not". And it also checks that the developed application fulfilling all the requirements given by the client.
    Verification is the process of checking that software achieves its goal without any bugs. It is the process to ensure whether the product that is developed is right or not. It verifies whether the developed product fulfills the requirements that we have. Verification is static testing. <br></br>
   <b>Verification activities include:</b><br>
   <b>Inspections: </b> examination of a product’s work-products.<br>
   <b>Reviews:</b> of the capability of the work-products to meet the specified requirements.<br>
   <b>Walkthroughs:</b> step-by-step presentation by the author of a document in order to gather information and to establish a common understanding of its content.<br>
   <b>Desk-checking:</b> The process where the developer reviews their own code or design to find errors.<br></br>
   <b>Validation</b><br></br>
Validation testing is testing where tester performed functional and non-functional testing. Here functional testing includes Unit Testing (UT), Integration Testing (IT) and System Testing (ST), and non-functional testing includes User acceptance testing (UAT).
Validation testing is also known as dynamic testing, where we are ensuring that "we have developed the product right." And it also checks that the software meets the business needs of the client.<br></br>
<b>Validation activities include:</b><br>
<b>Black Box Testing: </b> without knowledge of the internal workings of the application.<br>
<b>White Box Testing:</b> Testing with knowledge of the internal workings of the application.</br>
<b>Unit Testing:</b> Testing individual units or components of a software.</br>
<b>Testing:</b> Testing combined parts of an application to determine if they function together correctly.<br>
Non-functional Testing is a type of Software Testing that is performed to verify the non-functional requirements of the application. It verifies whether the behavior of the system is as per the requirement or not. It tests all the aspects that are not tested in functional testing. Non-functional testing is a software testing technique that checks the non-functional attributes of the system. Non-functional testing is defined as a type of software testing to check non-functional aspects of a software application. It is designed to test the readiness of a system as per nonfunctional parameters which are never addressed by functional testing. Non-functional testing is as important as functional testing. 
</p>
<img src="vl.png" alt="vl"class="responsive"><br></br>
<img src="ve.jpg" alt="ve" class="responsive"style="float: right;margin-top: -250px; "><br>
<h1>PROJECT MANEGMENT CYCLE AND PRODUCT MANEGMENT CYCLE</h1>
<h2>PROJECT LIFE CYCLE</h2><br>
<P>Project life cycles are a critical aspect of project management. They serve as an overview of what happens during every project stage and help ensure that everything is accounted for from beginning to end. The project life cycle usually has four phases: initiate, plan, execute, and close.
When it comes to planning and executing a project, the team consists of individuals who research solution ideas and create a plan, timeline, and milestones to complete any project. They then adapt and adjust as necessary to ensure the project's success.
In the post-close phase, the final details are wrapped up and final reports are delivered to the appropriate parties.<br><b>phase of project manegment life cycle:</b><br> <b>1. Initiate</b><br><b>2.  Plan</b><br><b>3. Execute</b><br> <b>4. Control</b><br><b>5. Close</b><br>
<img src="project.jpg" alt="project" class="responsive"style="float: right;margin-top:-130px;"><br></br>
<h2>PRODUCT MANEGMENT LIFE CYCLE</h2><br>
A product's life cycle might be represented by five stages: Development, Introduction, Growth, Maturity, and Decline. In the beginning, there were no sales yet. After people try the product and are receptive to it, there will begin to be some sales during the growth phase. Eventually, as sales decline, the competition comes and beats their performance. There is no set period for any of these stages: The company could very well stay in development for a long time before ever introducing a new product into the market, or the lifespan of one household appliance could be centuries, all depending on how often it gets used.</p>
<h2>WORK BREAKDOWN STRUCTURE IN SPM:</h2>
<p>A Work Breakdown Structure includes dividing a large and complex project into simpler, manageable, and independent tasks. The root of this tree (structure) is labeled by the Project name itself. For constructing a work breakdown structure, each node is recursively decomposed into smaller sub-activities, until at the leaf level, the activities become undividable and independent. It follows a Top-Down approach.
 <h2>Steps Work Breakdown Structure:</h2><b>Step 1:</b> Identify the major activities of the project.<br><b>Step 2:</b> Identify the sub-activities of the major activities.<br><b>Step 3:</b> Repeat till undividable, simple, and independent activities are created.<br>
 <h2>Uses of Work Breakdown Structure</h2><b>1.Cost estimation:</b> It allows doing a precise cost estimation of each activity.<br><b>2. Time estimation:</b> 3.  allows estimating the time that each activity will take more precisely.<br><b>4.  Easy project management:</b> allows easy management of the project.<br><b>5. Helps in project organization:</b> helps in proper organization of the project by the top management.<br> 
 <img src="wbs.jpg" alt="wbs" class="responsive"style="float: right;margin-top: -260px; "><br></br>
 <h2>Types of WBS</h2>
 <b>There are two main types of WBS: </b><br></b><b>1. deliverable-based</b><br></b><b>2. phase-Based</b><br></br> 
 <b>Deliverable-Based Work Breakdown Structure</b><br></br>
 A deliverable-based WBS first breaks down the project into all the major areas of the project scope as control accounts and then divides those into project deliverables and work packages.
 Here’s an example of a deliverable-based WBS that’s taken from our free work breakdown structure template. <br></br><b>Phase-Based Work Breakdown Structure:</b><br></br>
 The phase-based WBS displays the final deliverable on top, with the WBS levels below showing the five phases of a project (initiation, planning, execution, control and closeout). Just as in the deliverable-based WBS, the project phases are divided into project deliverables and work packages. Our previous graphic in the “Work Breakdown Structure Example” section contained a phase-based WBS example.
</p>
<h1>NETWORK DIAGRAMS IN SOFTWARE PROJECT MANEGMENT</h1>
<p>A network diagram is a visual representation of project tasks and their dependencies, crucial in project management for planning and scheduling. It illustrates the flow of work, sequence of tasks, and relationships between them, aiding project managers in understanding project complexity and optimizing resource allocation. By providing a clear overview of the project structure, network diagrams facilitate effective communication, decision-making, and risk management throughout the project lifecycle.A network diagram serves as a visual representation of project tasks, their relationships, and the flow of activities. Network diagrams provide a visual roadmap, highlighting critical paths and allowing project teams to identify dependencies, analyze project timelines, and optimize resource allocation for successful project execution.
<h2>Types of network diagrams</h2>
There are two main types of network diagrams commonly used in project management<br></br> <b>1. the Arrow Diagram Method (ADM)</b><br></br><b>2. the Precedence Diagram Method (PDM).</b><br></br> <b>1. Arrow Diagram:-</b>The Arrow Diagram Method (ADM), also known as the Activity Network Diagram or Activity on Arrow, is a graphical technique that represents activities as arrows and nodes to depict their relationships and dependencies. In ADM, the arrows represent activities, and the nodes represent events or milestones. The length of the arrows indicates the duration of each activity, and the arrows’ connections show the logical sequence of activities.
ADM aims to visualize the critical path, identify project constraints, and facilitate project scheduling and resource allocation. It provides a straightforward representation of project activities and their interdependencies.<br></br><b>2. PDM diagram</b>The Precedence Diagram Method (PDM), also referred to as the Node Network or Activity on Node, is another type of network diagram used in project management. PDM represents activities as nodes and uses arrows to depict relationships and dependencies. The nodes in PDM represent activities, and the arrows represent dependencies between them.
Unlike ADM, PDM focuses on the relationships between activities rather than their durations. PDM allows for flexibility in managing complex projects with multiple dependencies, as it can handle different types of relationships such as finish-to-start, start-to-start, finish-to-finish, and start-to-finish. It helps in determining the critical path, optimizing project schedules, and identifying potential bottlenecks or areas of risk.</p>
<br>
<h1>SOFTWARE PROJECT MANEGMENT CHART</h1>
<h2>Gantt Chart</h2>
<p>A Gantt Chart is a visual project management timeline that consists of horizontal bars, usually color-coded.
These bars show all the project tasks, when they are due, who is responsible, and how long each task will take.
    Therefore, Gantt charts illustrate the start and finish dates of the terminal elements and summary elements of a project.
    In other words, the Gantt chart assembles all pieces of tasks that are relative to a fixed deadline.<br></br>
    <b>Features of Gantt Chart</b><br></br>
1. Helps in Project Management
The Gantt Chart gives us a high-level interpretation of the Project timeline using which we can schedule our Project Delivery, wrap up the pending tasks, and extend the timeline according to the requirement.<br>
2. Simple to Use<br>
It has a drag-and-drop feature that enables us to easily make changes or update the timeframes of the tasks.
<br>
3. Supports Integration with Existing Projects<br>
You can easily integrate the Gantt Chart into your existing Project Workflow. Therefore, you do not need to create the Gantt Log from scratch.
<br>
4. Ideal for Complex Projects<br>
If the project structure is complex with multiple tasks or issues and the subtasks within them, the Gantt Chart serves as a proven solution to easily manage the complex work breakdown structure.
<br>
5. Provides Useful Insights along with Timelines<br>
A Gantt chart does not only deliver an overview of the sequence of events, but it also provides important information for project managers. Also, it visualizes the critical path and hence guides the schedulers’ attention to those activities that are crucial and deserve a specific treatment<br></br>
<img src="gt.webp" class="responsive" height="auto" width="100%"><br>
<b>How to Create a Gantt Chart?</b><br>
Although creating a Gantt Chart depends on multiple factors such as project status, its current phase, team size, deadlines, structure of tasks, and subtasks, it is easy to create it for your Project. The various steps in creating the Gantt Chart are stated below.
<br>
Step 1: List out every task you will need to complete to finish the project. For example, you can mention tasks such as Backend Configuration, Database Integration, Testing and Validation, Deployment, etc.
<br>
Step 2: Define chronological order and put each task in order of when it needs to be done. Also, identify whether some tasks depend on others or they need to be completed before any other tasks.
<br>
Step 3: Estimate how much time it will take you to complete each task to a level of quality that has been defined during the requirement elicitation and gathering.
<br>
Step 4: In this step, assign a realistic due date and start dates for each task. You should analyze whether the task execution will need some extra time or not.
<br>
Step 5: Fill up your Gantt Chart and Continuously update your Gantt chart with actual timelines.
We can easily create a Gantt Chart for our Project with the above steps. An example of a Gantt Chart is shown below including the Work Breakdown Structure, their due status, progress, and other information.</p><br>
<h2>PERT CHART</h2>
<P>Project Evaluation and Review Technique (PERT) is a procedure through which activities of a project are represented in its appropriate sequence and timing. It is a scheduling technique used to schedule, organize and integrate tasks within a project. PERT is basically a mechanism for management planning and control which provides blueprint for a particular project. All of the primary elements or events of a project have been finally identified by the PERT. In this technique, a PERT Chart is made which represent a schedule for all the specified tasks in the project. The reporting levels of the tasks or events in the PERT Charts is somewhat same as defined in the work breakdown structure (WBS).

    The PERT chart is used to schedule, organize and co-ordinate tasks within the project. the objective of PERT chart is to determine the critical path, which comprises critical activities that should be completed on schedule. This chart is prepared with the help of information generated in project planning activities such as estimation of effort, selection of suitable process model for software development and decomposition of tasks into subtasks.</P>
<br>
<b>Characteristics of PERT:</b><br>

The main characteristics of PERT are as following :<br>

It serves as a base for obtaining the important facts for implementing the decision-making.<br>
It forms the basis for all the planning activities.<br>
PERT helps management in deciding the best possible resource utilization method.<br>
PERT take advantage by using time network analysis technique.<br>
PERT presents the structure for reporting information.<br>
It helps the management in identifying the essential elements for the completion of the project within time.
<br>It specifies the activities that from the critical path.<br>
It describes the probability of completion of project before the specified date.<br>
It describes the dependencies of one or more tasks on each other.<br>
It represents the project in graphical plan form.<br></br>
<b>Advantages of PERT:</b><br>

It has the following advantages :<br>

Estimation of completion time of project is given by the PERT.<br>
It supports the identification of the activities with slack time.<br>
The start and dates of the activities of a specific project is determined.<br>
It helps project manager in identifying the critical path activities.<br>
PERT makes well organized diagram for the representation of large amount of data.<br></br>
<b>Disadvantages of PERT:</b><br>

It has the following disadvantages :<br>

The complexity of PERT is more which leads to the problem in implementation.<br>
Maintenance of PERT is also expensive and complex.<br>
The actual distribution of may be different from the PERT beta distribution which causes wrong assumptions.
<br>It under estimates the expected project completion time as there is chances that other paths can become the critical path if their related activities are deferred.
<img src="ptt.png" alt="ve" class="responsive"style="float: right;margin-top: -300px; "><br>
<div style="width:600px; margin:auto;">
<iframe width="100%" height="315" src="https://www.youtube.com/embed/SVf52pBl-3w?si=loSehVgu83FHnZ2e" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>
<footer class="footer">
    <div class="footer-content">
      <div class="footer-section">
        <h3>SOFTWARE PROJECT MAMAGMENT</h3>
        </div>
      </div>
    </footer>
</body>
</html>
